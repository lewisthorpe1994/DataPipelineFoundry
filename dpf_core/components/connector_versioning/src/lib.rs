use serde::Serialize;
use serde_json::Value;
use std::collections::{BTreeMap, HashMap};

#[derive(Copy, Clone, Eq, PartialEq, Ord, PartialOrd, Debug, Hash)]
pub struct Version {
    pub major: u8,
    pub minor: u8,
}
impl Version {
    pub const fn new(major: u8, minor: u8) -> Self {
        Self { major, minor }
    }

    /// Parse a version string in `MAJOR.MINOR` form (e.g. `"3.1"`).
    /// Returns an error string when the format is invalid or components
    /// cannot be parsed as `u8` values.
    pub fn parse(raw: &str) -> Result<Self, String> {
        let mut parts = raw.trim().split('.');

        let major_raw = parts
            .next()
            .ok_or_else(|| "expected MAJOR.MINOR".to_string())?;
        let minor_raw = parts
            .next()
            .ok_or_else(|| "expected MAJOR.MINOR".to_string())?;

        if parts.next().is_some() {
            return Err("unexpected extra version segments".to_string());
        }

        let major = major_raw
            .parse::<u8>()
            .map_err(|_| format!("invalid major version `{}`", major_raw))?;
        let minor = minor_raw
            .parse::<u8>()
            .map_err(|_| format!("invalid minor version `{}`", minor_raw))?;

        Ok(Self { major, minor })
    }
}
impl std::fmt::Display for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}.{}", self.major, self.minor)
    }
}

#[derive(Clone, Copy)]
pub struct ValueSpec {
    pub version: Version,
    pub values: &'static [&'static str],
}

pub fn version_supported(version: Version, supported: &[Version]) -> bool {
    supported.contains(&version)
}

pub fn values_for_version(
    specs: &[ValueSpec],
    version: Version,
) -> Option<&'static [&'static str]> {
    specs
        .iter()
        .find(|spec| spec.version == version)
        .map(|spec| spec.values)
}

#[derive(Copy, Clone, Debug)]
pub enum Compat {
    Always,
    Since(Version),
    Until(Version),
    Range { min: Version, max: Version },
}
impl Compat {
    pub fn allows(self, v: Version) -> bool {
        match self {
            Compat::Always => true,
            Compat::Since(min) => v >= min,
            Compat::Until(max) => v <= max,
            Compat::Range { min, max } => v >= min && v <= max,
        }
    }
}

/// Trait generated by the derive macro.
///
/// The macro will implement:
/// - `field_compat()` -> static compat table for serialized keys
/// - `validate_version(target)` -> collect errors for fields set but incompatible
/// - `to_versioned_map(target)` -> only include compatible fields (flattened)
pub trait ConnectorVersioned: Serialize {
    fn field_compat() -> &'static [(&'static str, Compat)];
    fn field_allowed_values() -> &'static [(&'static str, &'static [ValueSpec])] {
        &[]
    }
    fn validate_version(&self, target: Version) -> Vec<String> {
        let mut errs = Vec::new();

        let v = serde_json::to_value(self).unwrap_or(Value::Null);
        let Some(obj) = v.as_object() else {
            return errs;
        };

        let compat: HashMap<&'static str, Compat> = Self::field_compat().iter().copied().collect();

        for (key, val) in obj {
            // serde has already applied skip_serializing_if; only present keys matter
            if let Some(_non_null) = present(val) {
                let allowed = compat.get(key.as_str()).copied().unwrap_or(Compat::Always);
                if !allowed.allows(target) {
                    errs.push(format!(
                        "Field `{}` is not compatible with Debezium {}",
                        key, target
                    ));
                }
            }
        }
        errs
    }

    fn validate_allowed_values(&self, target: Version) -> Vec<String> {
        let mut errs = Vec::new();

        let v = serde_json::to_value(self).unwrap_or(Value::Null);
        let Some(obj) = v.as_object() else {
            return errs;
        };

        let allowed_map: HashMap<&'static str, &'static [ValueSpec]> =
            Self::field_allowed_values().iter().copied().collect();

        for (key, val) in obj {
            if let Some(specs) = allowed_map.get(key.as_str()) {
                if present(val).is_none() {
                    continue;
                }

                if let Some(actual) = value_to_string(val) {
                    if let Some(allowed) = values_for_version(specs, target) {
                        if !allowed.iter().any(|candidate| *candidate == actual) {
                            errs.push(format!(
                                "Field `{}` value `{}` is not compatible with Debezium {}",
                                key, actual, target
                            ));
                        }
                    } else {
                        errs.push(format!(
                            "Field `{}` is not supported for Debezium {}",
                            key, target
                        ));
                    }
                }
            }
        }

        errs
    }

    fn to_versioned_map(&self, target: Version) -> Result<BTreeMap<String, String>, String> {
        let mut out = BTreeMap::new();
        let v = serde_json::to_value(self).map_err(|e| e.to_string())?;
        let Some(obj) = v.as_object() else {
            return Ok(out);
        };

        let compat: HashMap<&'static str, Compat> = Self::field_compat().iter().copied().collect();

        for (k, val) in obj {
            if present(val).is_none() {
                continue;
            }
            let allowed = compat.get(k.as_str()).copied().unwrap_or(Compat::Always);
            if !allowed.allows(target) {
                continue;
            }

            // Flatten only simple primitivesâ€”extend as needed
            if let Some(s) = val.as_str() {
                out.insert(k.clone(), s.to_string());
            } else if let Some(b) = val.as_bool() {
                out.insert(k.clone(), b.to_string());
            } else if let Some(n) = val.as_i64() {
                out.insert(k.clone(), n.to_string());
            } else if let Some(n) = val.as_u64() {
                out.insert(k.clone(), n.to_string());
            } else if let Some(n) = val.as_f64() {
                out.insert(k.clone(), n.to_string());
            } else {
                // If you need arrays/objects, decide a policy here.
            }
        }
        Ok(out)
    }
}

fn present(v: &Value) -> Option<()> {
    match v {
        Value::Null => None,
        _ => Some(()),
    }
}

fn value_to_string(v: &Value) -> Option<String> {
    match v {
        Value::Null => None,
        Value::String(s) => Some(s.clone()),
        Value::Number(n) => Some(n.to_string()),
        Value::Bool(b) => Some(b.to_string()),
        other => Some(other.to_string()),
    }
}

#[cfg(test)]
mod tests {
    use super::Version;

    #[test]
    fn parse_valid_version() {
        let v = Version::parse("3.1").expect("parse version");
        assert_eq!(v.major, 3);
        assert_eq!(v.minor, 1);
    }

    #[test]
    fn parse_rejects_extra_segments() {
        let err = Version::parse("3.1.5").expect_err("expected error");
        assert!(err.contains("extra"));
    }

    #[test]
    fn parse_rejects_invalid_numbers() {
        let err = Version::parse("three.one").expect_err("expected error");
        assert!(err.contains("invalid major version"));
    }
}
