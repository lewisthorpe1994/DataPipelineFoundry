{
  "nodes": [
    {
      "name": "bronze.orders",
      "compiled_executable": "DROP TABLE IF EXISTS bronze.orders CASCADE;\nCREATE TABLE bronze.orders AS SELECT o.order_id, o.customer_id, o.order_date, o.total_amount FROM postgres.bronze.raw_orders AS o",
      "depends_on": [
        "postgres.bronze.raw_orders"
      ],
      "executable": true,
      "node_type": "DPF",
      "target": "warehouse_source"
    },
    {
      "name": "gold.customer_metrics",
      "compiled_executable": "DROP TABLE IF EXISTS gold.customer_metrics CASCADE;\nCREATE TABLE gold.customer_metrics AS SELECT o.customer_id, count(*) AS order_count, sum(o.total_amount) AS total_revenue FROM silver.orders AS o GROUP BY o.customer_id",
      "depends_on": [
        "silver.orders"
      ],
      "executable": true,
      "node_type": "DPF",
      "target": "warehouse_source"
    },
    {
      "name": "silver.orders",
      "compiled_executable": "DROP MATERIALIZED VIEW IF EXISTS silver.orders CASCADE;\nCREATE MATERIALIZED VIEW silver.orders AS SELECT o.order_id, o.customer_id, o.order_date, o.total_amount FROM bronze.orders AS o",
      "depends_on": [
        "bronze.orders"
      ],
      "executable": true,
      "node_type": "DPF",
      "target": "warehouse_source"
    },
    {
      "name": "public.orders",
      "compiled_executable": null,
      "depends_on": null,
      "executable": false,
      "node_type": "DB",
      "target": null
    },
    {
      "name": "postgres-.public.orders",
      "compiled_executable": null,
      "depends_on": [
        "test_src_connector"
      ],
      "executable": false,
      "node_type": "Kafka",
      "target": null
    },
    {
      "name": "mask_field",
      "compiled_executable": null,
      "depends_on": [
        "public.orders"
      ],
      "executable": false,
      "node_type": "Kafka",
      "target": null
    },
    {
      "name": "drop_id",
      "compiled_executable": null,
      "depends_on": [
        "public.orders"
      ],
      "executable": false,
      "node_type": "Kafka",
      "target": null
    },
    {
      "name": "test_src_connector",
      "compiled_executable": "{\"name\": test_src_connector, \"config\": {\"connector.class\":\"io.debezium.connector.postgresql.PostgresConnector\",\"database.dbname\":\"postgres\",\"database.hostname\":\"postgres\",\"database.password\":\"postgres\",\"database.port\":\"5432\",\"database.user\":\"postgres\",\"kafka.bootstrap.servers\":\"kafka-1:9092,kafka-2:9092,kafka-3:9092\",\"snapshot.mode\":\"initial\",\"table.include.list\":\"public.orders\",\"tasks.max\":\"1\",\"topic.prefix\":\"postgres-\",\"transforms\":\"pii_pipeline_mask_field,pii_pipeline_drop_id\",\"transforms.pii_pipeline_drop_id.blacklist\":\"id\",\"transforms.pii_pipeline_drop_id.predicate\":\"some_predicate\",\"transforms.pii_pipeline_drop_id.type\":\"org.apache.kafka.connect.transforms.ReplaceField$Value\",\"transforms.pii_pipeline_mask_field.fields\":\"name\",\"transforms.pii_pipeline_mask_field.predicate\":\"some_predicate\",\"transforms.pii_pipeline_mask_field.replacement\":\"X\",\"transforms.pii_pipeline_mask_field.type\":\"org.apache.kafka.connect.transforms.MaskField$Value\"}}",
      "depends_on": [
        "pii_pipeline",
        "public.orders"
      ],
      "executable": true,
      "node_type": "Kafka",
      "target": "some_kafka_cluster"
    },
    {
      "name": "unwrap_after",
      "compiled_executable": null,
      "depends_on": [
        "postgres-.public.orders"
      ],
      "executable": false,
      "node_type": "Kafka",
      "target": null
    },
    {
      "name": "customer_orders_sink",
      "compiled_executable": "{\"name\": customer_orders_sink, \"config\": {\"connection.password\":\"postgres\",\"connection.url\":\"jdbc:postgresql://postgres:5432/postgres\",\"connection.user\":\"postgres\",\"connector.class\":\"io.confluent.connect.jdbc.JdbcSinkConnector\",\"insert.mode\":\"upsert\",\"pk.fields\":\"customer_id\",\"pk.mode\":\"record_key\",\"table.name.format\":\"bronze.raw_orders\",\"tasks.max\":\"1\",\"topics\":\"postgres-.public.orders\",\"transforms\":\"customer_metrics_sink_pipeline_unwrap_after\",\"transforms.customer_metrics_sink_pipeline_unwrap_after.delete.handling.mode\":\"rewrite\",\"transforms.customer_metrics_sink_pipeline_unwrap_after.drop.tombstones\":\"true\",\"transforms.customer_metrics_sink_pipeline_unwrap_after.type\":\"io.debezium.transforms.ExtractNewRecordState\"}}",
      "depends_on": [
        "customer_metrics_sink_pipeline",
        "postgres-.public.orders"
      ],
      "executable": true,
      "node_type": "Kafka",
      "target": "some_kafka_cluster"
    },
    {
      "name": "postgres.bronze.raw_orders",
      "compiled_executable": null,
      "depends_on": [
        "customer_orders_sink"
      ],
      "executable": false,
      "node_type": "DB",
      "target": null
    },
    {
      "name": "customer_metrics_sink_pipeline",
      "compiled_executable": "CREATE SIMPLE MESSAGE TRANSFORM PIPELINE IF NOT EXISTS customer_metrics_sink_pipeline SINK (unwrap_after)",
      "depends_on": [
        "unwrap_after"
      ],
      "executable": false,
      "node_type": "Kafka",
      "target": null
    },
    {
      "name": "pii_pipeline",
      "compiled_executable": "CREATE SIMPLE MESSAGE TRANSFORM PIPELINE IF NOT EXISTS pii_pipeline SOURCE (mask_field, drop_id) WITH PIPELINE PREDICATE 'some_predicate'",
      "depends_on": [
        "drop_id",
        "mask_field"
      ],
      "executable": false,
      "node_type": "Kafka",
      "target": null
    },
    {
      "name": "postgres.bronze.raw_customers",
      "compiled_executable": null,
      "depends_on": null,
      "executable": false,
      "node_type": "DB",
      "target": null
    }
  ]
}